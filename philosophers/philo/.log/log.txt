=== start of ./philo.h ===
#ifndef PHILO_H
# define PHILO_H

/* Includes: */
# include <pthread.h>
# include <stdbool.h>

/* Types: */

typedef struct s_table
{
	int				size;
	int				tt_die;
	int				tt_eat;
	int				tt_sleep;
	int				servings;
	int				*m_stats;
	int				end_stat;
	int				print_stat;
	bool			done;
	bool			finite;
	long			start;
	struct s_philo	*philos;
	pthread_mutex_t	*forks;
	pthread_mutex_t	print_lock;
	pthread_mutex_t	end_lock;
}	t_table;

typedef struct s_philo
{
	int				id;
	int				meal_count;
	int				m_stat;
	int				t_stat;
	int				tt_think;
	long			last_meal;
	bool			alive;
	t_table			*table;
	pthread_t		thread;
	pthread_mutex_t	philock;
	pthread_mutex_t	*l_fork;
	pthread_mutex_t	*r_fork;
}	t_philo;

typedef enum e_actions
{
	THINK = 33,
	PICK = 33,
	EAT = 32,
	SLEEP = 33,
	DIE = 31
}	t_actions;

/* Macros: */

# define ARG_ERR "N, death_time, meal_time, sleep_time [, N_meals]\n"
# define VAL_ERR "All arguments must be positive integers\n"
# define MAL_ERR "Malloc failed please try again\n"
# define THR_ERR "Thread/Mutex creation failed, please try again\n"


/* Functions: */
int		ft_atopi(char *str);
int		ft_cleanup(t_table *t);
int		ft_death_watch(t_table *table);
int		ft_handle_error(int code, t_table *table);
int		ft_boot_sim(t_table *table);
long	ft_clock(void);
void	ft_printer(int action, char *msg, t_philo *philo);
void	*ft_routine(void *arg);

#endif
=== end of ./philo.h ===
=== start of ./philo.c ===

#include "philo.h"
#include <pthread.h>
#include <stdlib.h>

static int	init_mutex(t_table *t, int n)
{
	int	i;

	i = -1;
	while (++i < n)
	{
		t->m_stats[i] = pthread_mutex_init(&t->forks[i], NULL);
		t->philos[i].m_stat = pthread_mutex_init(&t->philos[i].philock, NULL);
	}
	t->print_stat = pthread_mutex_init(&t->print_lock, NULL);
	t->end_stat = pthread_mutex_init(&t->end_lock, NULL);
	if (t->print_stat || t->end_stat)
		return (0);
	i = -1;
	while (++i < n)
	{
		if (t->m_stats[i] != 0 || t->philos[i].m_stat != 0)
			return (0);
	}
	return (1);
}

static int	init(int ac, int args[5], t_table *t)
{
	t->size = args[0];
	t->tt_die = args[1];
	t->tt_eat = args[2];
	t->tt_sleep = args[3];
	if (ac == 6)
	{
		t->finite = true;
		t->servings = args[4];
	}
	else
	{
		t->finite = false;
		t->servings = -1;
	}
	t->done = false;
	return (init_mutex(t, args[0]));
}

static t_table	*set_t(int n)
{
	t_table *new_t;

	new_t = malloc(sizeof(t_table));
	if (!new_t)
		return (NULL);
	new_t->philos = NULL;
	new_t->forks = NULL;
	new_t->m_stats = NULL;
	new_t->philos = malloc(sizeof(t_philo) * n);
	new_t->forks = malloc(sizeof(pthread_mutex_t) * n);
	new_t->m_stats = malloc(sizeof(int) * n);
	return (new_t);
}

int main(int ac, char **av)
{
	int		i;
	int		args[5];
	t_table	*table;

	if (ac != 5 && ac != 6)
		return (ft_handle_error(1, NULL));
	i = 0;
	while (++i < ac)
		args[i - 1] = ft_atopi(av[i]);
	i = -1;
	while (++i < ac - 1)
	{
		if (args[i] == 0)
			return (ft_handle_error(2, NULL));
	}
	table = set_t(args[0]);
	if (!table || !table->philos || !table->forks || !table->m_stats)
		return (ft_handle_error(3, table));
	if (!init(ac, args, table))
		return (ft_handle_error(4, table));
	return (ft_boot_sim(table));
}
=== end of ./philo.c ===
=== start of ./error.c ===

#include "philo.h"
#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>

static void	erase_table(t_table *t)
{
	if (t->philos)
		free(t->philos);
	if (t->forks)
		free(t->forks);
	if (t->m_stats)
		free(t->m_stats);
	free(t);
	t = NULL;
}

static void	erase_mutex(t_table *t)
{
	int	i;

	i = -1;
	while (++i < t->size)
	{
		if (t->m_stats[i] == 0)
			pthread_mutex_destroy(&t->forks[i]);
		if (t->philos[i].m_stat == 0)
			pthread_mutex_destroy(&t->philos[i].philock);
	}
	if (t->print_stat == 0)
		pthread_mutex_destroy(&t->print_lock);
	if (t->end_stat == 0)
		pthread_mutex_destroy(&t->end_lock);
}

static int	clean_errors(int c, t_table *t)
{
	if (c == 3)
	{
		erase_table(t);
		printf("%s", MAL_ERR);
	}
	if (c == 4)
	{
		erase_mutex(t);
		erase_table(t);
		printf("%s", THR_ERR);
	}
	return (c);
}

int	ft_handle_error(int code, t_table *table)
{
	if (code != 1)
		printf("Error: ");
	if (table)
		return (clean_errors(code, table));
	if (code == 1)
		printf("Use: ./philosophers %s", ARG_ERR);
	if (code == 2)
		printf("%s", VAL_ERR);
	if (code == 3)
		printf("%s", MAL_ERR);
	return (code);
}
=== end of ./error.c ===
=== start of ./utils.c ===

#include "philo.h"
#include <stdio.h>
#include <limits.h>
#include <pthread.h>
#include <sys/time.h>

long	ft_clock(void)
{
	struct timeval	tv;

	gettimeofday(&tv, NULL);
	return ((tv.tv_sec * 1000) + (tv.tv_usec / 1000L));
}

void	ft_printer(int action, char *msg, t_philo *philo)
{
	long	now;

	pthread_mutex_lock(&philo->table->print_lock);
	printf("\033[%dm", action);
	now = ft_clock() - philo->table->start;
	printf("%ld %d %s\n\033[0m", now, philo->id, msg);
	pthread_mutex_unlock(&philo->table->print_lock);
}

int	ft_atopi(char *s)
{
	long	result;

	result = 0;
	while ((*s >= 9 && *s <= 13) || *s == ' ')
		s++;
	if (*s == '+')
		s++;
	while (*s >= '0' && *s <= '9')
	{
		result *= 10;
		result += *s - '0';
		s++;
	}
	if (*s || result < 0 || result > INT_MAX)
		return (0);
	return ((int)result);
}
=== end of ./utils.c ===
=== start of ./sim.c ===

#include "philo.h"
#include <pthread.h>

static void	make_philo(int i, t_philo *p, t_table *t)
{
	p->id = i + 1;
	p->meal_count = 0;
	p->alive = true;
	p->table = t;
	p->l_fork = &p->table->forks[p->id % t->size];
	p->r_fork = &p->table->forks[p->id - 1];
	if (i % 2)
	{
		p->l_fork = &p->table->forks[p->id - 1];
		p->r_fork = &p->table->forks[p->id % t->size];
	}
	p->tt_think = p->id % 3;
	p->last_meal = ft_clock();
}

static int	broken_thread(t_table *t)
{
	int	i;

	i = -1;
	while (++i < t->size)
	{
		if (t->philos[i].t_stat == 0)
			pthread_join(t->philos[i].thread, NULL);
	}
	return (ft_handle_error(4, t));
}

int	ft_boot_sim(t_table *table)
{
	int	i;

	i = -1;
	while (++i < table->size)
		make_philo(i, &table->philos[i], table);
	i = -1;
	table->start = ft_clock();
	while (++i < table->size)
		table->philos[i].t_stat = pthread_create(&table->philos[i].thread, NULL, ft_routine, &table->philos[i]);
	i = -1;
	while (++i < table->size)
	{
		if (table->philos[i].t_stat != 0)
			return (broken_thread(table));
	}
	return (ft_death_watch(table));
}
=== end of ./sim.c ===
=== start of ./routine.c ===

#include "philo.h"
#include <pthread.h>
#include <unistd.h>

static int	take_action(int tt, int code, char *m, t_philo *p)
{
	bool	still_alive;

	pthread_mutex_lock(&p->table->end_lock);
	if (p->table->done)
	{
		pthread_mutex_unlock(&p->table->end_lock);
		return (0);
	}
	pthread_mutex_unlock(&p->table->end_lock);
	ft_printer(code, m, p);
	usleep(1000L * (long)tt);
	pthread_mutex_lock(&p->philock);
	still_alive = p->alive;
	pthread_mutex_unlock(&p->philock);
	if (!still_alive)
		return (0);
	return (1);
}

static int	meal_time(t_philo *p)
{
	int	flag;

	pthread_mutex_lock(p->l_fork);
	if (!take_action(0, PICK, "has taken a fork", p))
	{
		pthread_mutex_unlock(p->l_fork);
		return (0);
	}
	pthread_mutex_lock(p->r_fork);
	if (!take_action(0, PICK, "has taken a fork", p))
	{
		pthread_mutex_unlock(p->l_fork);
		pthread_mutex_unlock(p->r_fork);
		return (0);
	}
	pthread_mutex_lock(&p->philock);
	p->last_meal = ft_clock();
	if (p->table->finite)
		p->meal_count += 1;
	pthread_mutex_unlock(&p->philock);
	flag = take_action(p->table->tt_eat, EAT, "is eating", p);
	pthread_mutex_unlock(p->l_fork);
	pthread_mutex_unlock(p->r_fork);
	return (flag);
}

void	*ft_routine(void *arg)
{
	t_philo	*self;

	self = (t_philo *)arg;
	while (1)
	{
		if (!take_action(self->tt_think, THINK, "is thinking", self))
			break ;
		if (!meal_time(self))
			break ;
		if (!take_action(self->table->tt_sleep, SLEEP, "is sleeping", self))
			break ;
	}
	return (NULL);
}
=== end of ./routine.c ===
=== start of ./looper.c ===

#include "philo.h"
#include <pthread.h>
#include <unistd.h>

static int	done_check(t_table *t)
{
	int	i;

	i = -1;
	while (++i < t->size)
	{
		pthread_mutex_lock(&t->philos[i].philock);
		if (t->philos[i].meal_count < t->servings)
		{
			pthread_mutex_unlock(&t->philos[i].philock);
			return (0);
		}
		pthread_mutex_unlock(&t->philos[i].philock);
	}
	return (1);
}

static int	death_check(t_table *t)
{
	int	i;

	i = -1;
	while (++i < t->size)
	{
		pthread_mutex_lock(&t->philos[i].philock);
		if (ft_clock() - t->philos[i].last_meal >= t->tt_die)
		{
			t->philos[i].alive = false;
			pthread_mutex_lock(&t->end_lock);
			t->done = true;
			pthread_mutex_unlock(&t->end_lock);
			pthread_mutex_unlock(&t->philos[i].philock);
			ft_printer(DIE, "has died", &t->philos[i]);
			return (1);
		}
		pthread_mutex_unlock(&t->philos[i].philock);
	}
	return (0);
}

int	ft_death_watch(t_table *t)
{
	int		i;

	while (1)
	{
		if (death_check(t))
			break ;
		if (t->finite && done_check(t))
			break ;
		usleep(1000);
	}
	i = -1;
	while (++i < t->size)
		pthread_join(t->philos[i].thread, NULL);
	return (ft_cleanup(t));
}
=== end of ./looper.c ===
=== start of ./cleaner.c ===

#include "philo.h"
#include <stdlib.h>
#include <pthread.h>

static void	undo_mutexes(t_table *t)
{
	int	i;

	i = -1;
	while (++i < t->size)
	{
		if (t->philos[i].m_stat == 0)
			pthread_mutex_destroy(&t->philos[i].philock);
		if (t->m_stats[i] == 0)
			pthread_mutex_destroy(&t->forks[i]);
	}
	if (t->print_stat == 0)
		pthread_mutex_destroy(&t->print_lock);
	if (t->end_stat == 0)
		pthread_mutex_destroy(&t->end_lock);
}

static void	undo_mallocs(t_table *t)
{
	if (!t)
		return ;
	if (t->forks)
		free(t->forks);
	if (t->philos)
		free(t->philos);
	if (t->m_stats)
		free(t->m_stats);
	free(t);
}

int	ft_cleanup(t_table *t)
{
	undo_mutexes(t);
	undo_mallocs(t);
	return (0);
}
=== end of ./cleaner.c ===
