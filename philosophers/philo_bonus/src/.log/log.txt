=== start of ./philo_bonus.h ===
#ifndef PHILO_BONUS_H
# define PHILO_BONUS_H

/* Includes: */
# include <stdbool.h>
# include <semaphore.h>
# include <sys/types.h>

/* Types: */

typedef enum e_colors
{
	THINK = 33,
	PICK = 33,
	SLEEP = 33,
	EAT = 32,
	DIE = 31
}	t_colors;

typedef struct s_cave
{
	int		size;
	int		tt_die;
	int		tt_eat;
	int		tt_sleep;
	int		servings;
	long	start;
	long	last_meal;
	bool	finite;
	bool	done;
	sem_t	*forks;
	sem_t	*printer;
	sem_t	*death_flag;
	pid_t	*pids;
}	t_cave;

/* Macros: */
# define IMPO 0 << 0
# define DIED 1 << 0
# define FINI 1 << 1
# define FORKS_SEM "/forks"
# define PRINT_SEM "/printer"
# define DEATH_SEM "/death_flag"
# define ARG_ERR "N, death_time, meal_time, sleep_time [, N_meals]\n"
# define VAL_ERR "All arguments must be positive INTs\n"
# define SEM_ERR "Error creating semaphore\n"
# define MAL_ERR "Internal error using malloc\n"


/* Functions: */

int		ft_atopi(char *str);
int		ft_cleanup(t_cave *cave);
int		ft_boot_sim(t_cave *cave);
int		ft_handle_error(int code, t_cave *cave);
long	ft_clock(void);
void	ft_printer(int id, int action, char *msg, t_cave *cave);
void	ft_routine(t_cave *cave, int id);
#endif
=== end of ./philo_bonus.h ===
=== start of ./philo_bonus.c ===

#include "philo_bonus.h"
#include <fcntl.h>
#include <semaphore.h>
#include <stdlib.h>
#include <sys/types.h>

static int	parse_pids(t_cave *cave)
{
	cave->pids = malloc(sizeof(pid_t) * cave->size);
	if (!cave->pids)
		return (0);
	return (1);
}

static int	parse_sems(t_cave *cave)
{
	sem_unlink(FORKS_SEM);
	sem_unlink(PRINT_SEM);
	sem_unlink(DEATH_SEM);
	cave->forks = sem_open(FORKS_SEM, O_CREAT, 0644, cave->size);
	cave->printer = sem_open(PRINT_SEM, O_CREAT, 0644, 1);
	cave->death_flag = sem_open(DEATH_SEM, O_CREAT, 0644, 0);
	if (cave->forks == SEM_FAILED || cave->printer == SEM_FAILED
		|| cave->death_flag == SEM_FAILED)
		return (0);
	return (1);
}

static int	parse_args(char **av, t_cave *cave)
{
	cave->size = ft_atopi(av[0]);
	cave->tt_die = ft_atopi(av[1]);
	cave->tt_eat = ft_atopi(av[2]);
	cave->tt_sleep = ft_atopi(av[3]);
	if (!cave->size || !cave->tt_die || !cave->tt_eat || !cave->tt_sleep)
		return (0);
	cave->done = false;
	cave->finite = false;
	cave->servings = -1;
	if (!av[4])
		return (1);
	cave->servings = ft_atopi(av[4]);
	if (!cave->servings)
		return (0);
	cave->finite = true;
	return (1);
}

#include <stdio.h>

int	main(int ac, char **av)
{
	static t_cave	cave;

	if (ac != 5 && ac != 6)
		return (ft_handle_error(1, NULL));
	if (!parse_args(av + 1, &cave))
		return (ft_handle_error(2, NULL));
	if (!parse_sems(&cave))
		return (ft_handle_error(3, &cave));
	if (!parse_pids(&cave))
		return (ft_handle_error(4, &cave));
	ft_boot_sim(&cave);
}
=== end of ./philo_bonus.c ===
=== start of ./utils_bonus.c ===

#include <semaphore.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <sys/time.h>
#include "philo_bonus.h"

long	ft_clock(void)
{
	struct timeval	tv;

	gettimeofday(&tv, NULL);
	return ((tv.tv_sec * 1000) + (tv.tv_usec / 1000L));
}

void	ft_printer(int i, int a, char *m, t_cave *c)
{
	long	now;

	now = ft_clock() - c->start;
	sem_wait(c->printer);
	printf("\033[%dm%ld %d %s\033[0m\n", a, now, i, m);
	sem_post(c->printer);
}

int	ft_atopi(char *s)
{
	long	result;

	result = 0;
	while ((*s >= 9 && *s <= 13) || *s == ' ')
		s++;
	if (*s == '+')
		s++;
	while (*s >= '0' && *s <= '9')
	{
		result *= 10;
		result += *s - '0';
		s++;
	}
	while ((*s >= 9 && *s <= 13) || *s == ' ')
		s++;
	if (*s || result < 0 || result > INT_MAX)
		return (0);
	return ((int)result);
}
=== end of ./utils_bonus.c ===
=== start of ./error_bonus.c ===

#include "philo_bonus.h"
#include <semaphore.h>
#include <unistd.h>

static void	clean_semaphores(t_cave *c)
{
	if (c->forks != SEM_FAILED)
		sem_close(c->forks);
	if (c->printer != SEM_FAILED)
		sem_close(c->printer);
	if (c->death_flag != SEM_FAILED)
		sem_close(c->death_flag);
	sem_unlink(FORKS_SEM);
	sem_unlink(PRINT_SEM);
	sem_unlink(DEATH_SEM);
}

static int	clean_errors(int code, t_cave *cave)
{
	clean_semaphores(cave);
	if (code == 3)
		write(2, SEM_ERR, sizeof(SEM_ERR) - 1);
	if (code == 4)
		write(2, MAL_ERR, sizeof(MAL_ERR) - 1);
	return (code);
}

int	ft_handle_error(int code, t_cave *cave)
{
	if (code != 1)
		write(2, "Error: ", sizeof("Error: ") - 1);
	if (cave)
		return (clean_errors(code, cave));
	if (code == 1)
	{
		write(2, "Use: ./philosophers_bonus ", 26);
		write(2, ARG_ERR, sizeof(ARG_ERR) - 1);
	}
	if (code == 2)
		write(2, VAL_ERR, sizeof(VAL_ERR) - 1);
	return (code);
}
=== end of ./error_bonus.c ===
=== start of ./sim_bonus.c ===

#include "philo_bonus.h"
#include <semaphore.h>
#include <signal.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>

static void	monitor(t_cave *cave)
{
	int		i;
	int		status;
	int		done;
	pid_t	tempid;

	done = 0;
	while (done < cave->size)
	{
		tempid = waitpid(-1, &status, 0);
		if (tempid <= 0)
			continue ;
		if (WIFEXITED(status))
		{
			status = WEXITSTATUS(status);
			if (status == DIED)
			{
				i = -1;
				while (++i < cave->size)
					kill(cave->pids[i], SIGTERM);
				break ;
			}
			else if (status == FINI)
				done++;
		}
	}
}

int	ft_boot_sim(t_cave *cave)
{
	int	i;

	i = -1;
	cave->start = ft_clock();
	while (++i < cave->size)
	{
		cave->pids[i] = fork();
		if (cave->pids[i] < 0)
			return (ft_handle_error(5, cave));
		if (cave->pids[i] == 0)
		{
			ft_routine(cave, i + 1);
			exit(IMPO);
		}
	}
	monitor(cave);
	return (ft_cleanup(cave));
}
=== end of ./sim_bonus.c ===
=== start of ./routine_bonus.c ===

#include "philo_bonus.h"
#include <semaphore.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>

static void	safe_sleep(int id, int tt, t_cave *c, bool literal)
{
	if (!literal)
		tt *= 1000;
	while (tt > 0)
	{
		usleep(100);
		if (ft_clock() - c->start > c->last_meal)
		{
			ft_printer(id, DIE, "has died", c);
			exit(DIED);
		}
		tt -= 100;
	}
}

static void	take_action(int i, int a, char *m, t_cave *c)
{
	long	now;

	now = ft_clock();
	if (now - c->start > c->tt_die)
	{
		ft_printer(i, DIE, "has died", c);
		exit(DIED);
	}
	else
		ft_printer(i, a, m, c);
}

void	ft_routine(t_cave *cave, int id)
{
	cave->last_meal = ft_clock();
	while (!cave->done)
	{
		take_action(id, THINK, "is thinking", cave);
		usleep((id * 100) % (cave->tt_die / 2));
		safe_sleep(id, (id * 100) % (cave->tt_die / 2), cave, true);
		sem_wait(cave->forks);
		take_action(id, PICK, "has taken a fork", cave);
		sem_wait(cave->forks);
		take_action(id, PICK, "has taken a fork", cave);
		cave->last_meal = ft_clock();
		take_action(id, EAT, "is eating", cave);
		safe_sleep(id, cave->tt_eat, cave, false);
		sem_post(cave->forks);
		sem_post(cave->forks);
		if (cave->finite)
		{
			cave->servings -= 1;
			if (!cave->servings)
				exit(FINI);
		}
		take_action(id, SLEEP, "is sleeping", cave);
		safe_sleep(id, cave->tt_sleep, cave, false);
	}
}
=== end of ./routine_bonus.c ===
=== start of ./cleanup_bonus.c ===

#include "philo_bonus.h"

int ft_cleanup(t_cave *cave)
{
	return (0);
}
=== end of ./cleanup_bonus.c ===
